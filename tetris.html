<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tetris Game</title>
  <style>
    body {
      background: #181a1b;
      color: #fff;
      font-family: 'Segoe UI', Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
    }
    #tetris {
      background: #222 url('images/tetris.jpg') center center/cover no-repeat;
      border: 4px solid #a06bff;
      border-radius: 12px;
      box-shadow: 0 4px 32px #a06bff33;
      margin-bottom: 8px;
      display: grid;
      grid-template-rows: repeat(20, 28px);
      grid-template-columns: repeat(10, 28px);
      position: relative;
    }
    h1 {
      margin-bottom: 12px;
      font-size: 2.2em;
      color: #a06bff;
      text-shadow: 0 2px 8px #a06bff44;
    }
    #tetris-container {
      display: flex;
      gap: 32px;
      align-items: flex-start;
    }
    #tetris {
      display: grid;
      grid-template-rows: repeat(20, 28px);
      grid-template-columns: repeat(10, 28px);
      background: #222;
      border: 4px solid #a06bff;
      border-radius: 12px;
      box-shadow: 0 4px 32px #a06bff33;
      margin-bottom: 8px;
    }
    .cell {
      width: 28px;
      height: 28px;
      box-sizing: border-box;
      border: 1px solid #222;
      background: #222;
      transition: background 0.1s;
    }
    .cell {
      width: 28px;
      height: 28px;
      box-sizing: border-box;
      border: 1px solid #222;
      background: #222;
      transition: background 0.1s;
      background-image: url('images/block.jpg');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      filter: grayscale(1) brightness(0.7);
    }
    .cell.I { filter: hue-rotate(180deg) brightness(1.2) saturate(2); }
    .cell.J { filter: hue-rotate(240deg) brightness(1.1) saturate(2); }
    .cell.L { filter: hue-rotate(30deg) brightness(1.1) saturate(2); }
    .cell.O { filter: hue-rotate(60deg) brightness(1.3) saturate(2); }
    .cell.S { filter: hue-rotate(90deg) brightness(1.2) saturate(2); }
    .cell.T { filter: hue-rotate(270deg) brightness(1.1) saturate(2); }
    .cell.Z { filter: hue-rotate(0deg) brightness(1.1) saturate(2); }
    .cell.ghost { opacity: 0.3; }

    .cell.I::after { background: rgba(0,240,240,0.55); }
    .cell.J::after { background: rgba(0,0,240,0.55); }
    .cell.L::after { background: rgba(240,160,0,0.55); }
    .cell.O::after { background: rgba(240,240,0,0.55); }
    .cell.S::after { background: rgba(0,240,0,0.55); }
    .cell.T::after { background: rgba(160,0,240,0.55); }
    .cell.Z::after { background: rgba(240,0,0,0.55); }
    .cell.I::after, .cell.J::after, .cell.L::after, .cell.O::after, .cell.S::after, .cell.T::after, .cell.Z::after {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      border-radius: 4px;
      pointer-events: none;
      z-index: 1;
      mix-blend-mode: lighten;
    }
    .cell { position: relative; }
    #side-panel {
      display: flex;
      flex-direction: column;
      gap: 18px;
      align-items: center;
    }
    #score {
      font-size: 1.3em;
      color: #ffd93d;
      margin-bottom: 8px;
    }
    #next {
      display: grid;
      grid-template-rows: repeat(4, 20px);
      grid-template-columns: repeat(4, 20px);
      background: #333;
      border: 2px solid #a06bff;
      border-radius: 8px;
      margin-bottom: 8px;
    }
    .next-cell {
      width: 20px;
      height: 20px;
      box-sizing: border-box;
      border: 1px solid #333;
      background: #333;
      background-image: url('images/block.jpg');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      filter: grayscale(1) brightness(0.7);
    }
    .next-cell.I { filter: hue-rotate(180deg) brightness(1.2) saturate(2); }
    .next-cell.J { filter: hue-rotate(240deg) brightness(1.1) saturate(2); }
    .next-cell.L { filter: hue-rotate(30deg) brightness(1.1) saturate(2); }
    .next-cell.O { filter: hue-rotate(60deg) brightness(1.3) saturate(2); }
    .next-cell.S { filter: hue-rotate(90deg) brightness(1.2) saturate(2); }
    .next-cell.T { filter: hue-rotate(270deg) brightness(1.1) saturate(2); }
    .next-cell.Z { filter: hue-rotate(0deg) brightness(1.1) saturate(2); }

    .next-cell.I::after { background: rgba(0,240,240,0.55); }
    .next-cell.J::after { background: rgba(0,0,240,0.55); }
    .next-cell.L::after { background: rgba(240,160,0,0.55); }
    .next-cell.O::after { background: rgba(240,240,0,0.55); }
    .next-cell.S::after { background: rgba(0,240,0,0.55); }
    .next-cell.T::after { background: rgba(160,0,240,0.55); }
    .next-cell.Z::after { background: rgba(240,0,0,0.55); }
    .next-cell.I::after, .next-cell.J::after, .next-cell.L::after, .next-cell.O::after, .next-cell.S::after, .next-cell.T::after, .next-cell.Z::after {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      border-radius: 4px;
      pointer-events: none;
      z-index: 1;
      mix-blend-mode: lighten;
    }
    .next-cell { position: relative; }
    #controls {
      color: #fff;
      font-size: 1em;
      background: #232323;
      border-radius: 8px;
      padding: 10px 18px;
      box-shadow: 0 2px 8px #a06bff22;
      margin-top: 8px;
      text-align: center;
    }
    #restartBtn {
      margin-top: 10px;
      background: #a06bff;
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 8px 18px;
      font-size: 1em;
      cursor: pointer;
      box-shadow: 0 2px 8px #a06bff33;
      transition: background 0.2s;
    }
    #restartBtn:hover {
      background: #7c4dff;
    }
  </style>
</head>
<body>
  <h1>Tetris Game</h1>
  <div id="tetris-container">
    <div>
      <div id="tetris"></div>
    </div>
    <div id="side-panel">
      <div id="score">Score: 0</div>
      <div>Next:</div>
      <div id="next"></div>
      <button id="restartBtn">Restart</button>
      <div id="controls">
        Controls:<br>
        ← → : Move<br>
        ↑ : Rotate<br>
        ↓ : Soft Drop<br>
        Space: Hard Drop
      </div>
    </div>
  </div>
  <script>
    // Tetris constants
    const ROWS = 20, COLS = 10;
    const TETROMINOES = {
      I: [
        [[0,1],[1,1],[2,1],[3,1]],
        [[2,0],[2,1],[2,2],[2,3]],
        [[0,2],[1,2],[2,2],[3,2]],
        [[1,0],[1,1],[1,2],[1,3]]
      ],
      J: [
        [[0,0],[0,1],[1,1],[2,1]],
        [[1,0],[2,0],[1,1],[1,2]],
        [[0,1],[1,1],[2,1],[2,2]],
        [[1,0],[1,1],[0,2],[1,2]]
      ],
      L: [
        [[2,0],[0,1],[1,1],[2,1]],
        [[1,0],[1,1],[1,2],[2,2]],
        [[0,1],[1,1],[2,1],[0,2]],
        [[0,0],[1,0],[1,1],[1,2]]
      ],
      O: [
        [[1,0],[2,0],[1,1],[2,1]],
        [[1,0],[2,0],[1,1],[2,1]],
        [[1,0],[2,0],[1,1],[2,1]],
        [[1,0],[2,0],[1,1],[2,1]]
      ],
      S: [
        [[1,0],[2,0],[0,1],[1,1]],
        [[1,0],[1,1],[2,1],[2,2]],
        [[1,1],[2,1],[0,2],[1,2]],
        [[0,0],[0,1],[1,1],[1,2]]
      ],
      T: [
        [[1,0],[0,1],[1,1],[2,1]],
        [[1,0],[1,1],[2,1],[1,2]],
        [[0,1],[1,1],[2,1],[1,2]],
        [[1,0],[0,1],[1,1],[1,2]]
      ],
      Z: [
        [[0,0],[1,0],[1,1],[2,1]],
        [[2,0],[1,1],[2,1],[1,2]],
        [[0,1],[1,1],[1,2],[2,2]],
        [[1,0],[0,1],[1,1],[0,2]]
      ]
    };
    const COLORS = ['I','J','L','O','S','T','Z'];
    // Game state
    let grid, current, next, score, interval, gameOver;
    const tetris = document.getElementById('tetris');
    const nextDiv = document.getElementById('next');
    const scoreDiv = document.getElementById('score');
    const restartBtn = document.getElementById('restartBtn');
    function createGrid() {
      grid = [];
      tetris.innerHTML = '';
      for (let r = 0; r < ROWS; r++) {
        let row = [];
        for (let c = 0; c < COLS; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          tetris.appendChild(cell);
          row.push(cell);
        }
        grid.push(row);
      }
    }
    function createNext() {
      nextDiv.innerHTML = '';
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          const cell = document.createElement('div');
          cell.className = 'next-cell';
          nextDiv.appendChild(cell);
        }
      }
    }
    function drawNext() {
      const cells = nextDiv.querySelectorAll('.next-cell');
      cells.forEach(cell => cell.className = 'next-cell');
      const shape = TETROMINOES[next.type][0];
      shape.forEach(([x, y]) => {
        const idx = y * 4 + x;
        if (cells[idx]) cells[idx].classList.add(next.type);
      });
    }
    function randomTetromino() {
      const type = COLORS[Math.floor(Math.random() * COLORS.length)];
      return { type, rotation: 0, x: 3, y: 0 };
    }
    function canMove(tet, dx, dy, dr) {
      const shape = TETROMINOES[tet.type][(tet.rotation + dr + 4) % 4];
      for (const [x, y] of shape) {
        const nx = tet.x + x + dx;
        const ny = tet.y + y + dy;
        if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) return false;
        if (ny >= 0 && grid[ny][nx].classList.contains('filled')) return false;
      }
      return true;
    }
    function drawTetromino(tet, ghost=false) {
      const shape = TETROMINOES[tet.type][tet.rotation];
      for (const [x, y] of shape) {
        const nx = tet.x + x;
        const ny = tet.y + y;
        if (ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
          grid[ny][nx].classList.add(ghost ? 'ghost' : tet.type);
        }
      }
    }
    function undrawTetromino(tet) {
      const shape = TETROMINOES[tet.type][tet.rotation];
      for (const [x, y] of shape) {
        const nx = tet.x + x;
        const ny = tet.y + y;
        if (ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
          grid[ny][nx].classList.remove('I','J','L','O','S','T','Z','ghost');
        }
      }
    }
    function hardDropPos(tet) {
      let ghost = { ...tet };
      while (canMove(ghost, 0, 1, 0)) ghost.y++;
      return ghost;
    }
    function mergeTetromino(tet) {
      const shape = TETROMINOES[tet.type][tet.rotation];
      for (const [x, y] of shape) {
        const nx = tet.x + x;
        const ny = tet.y + y;
        if (ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
          grid[ny][nx].classList.add('filled', tet.type);
        }
      }
    }
    function clearLines() {
      let lines = 0;
      for (let r = ROWS - 1; r >= 0; r--) {
        if (grid[r].every(cell => cell.classList.contains('filled'))) {
          for (let rr = r; rr > 0; rr--) {
            for (let c = 0; c < COLS; c++) {
              grid[rr][c].className = grid[rr-1][c].className;
            }
          }
          for (let c = 0; c < COLS; c++) {
            grid[0][c].className = 'cell';
          }
          lines++;
          r++;
        }
      }
      if (lines > 0) score += [0,40,100,300,1200][lines];
    }
    function update() {
      if (gameOver) return;
      undrawTetromino(current);
      // Remove old ghost
      for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) grid[r][c].classList.remove('ghost');
      // Draw ghost
      drawTetromino(hardDropPos(current), true);
      // Draw current
      drawTetromino(current);
      scoreDiv.textContent = 'Score: ' + score;
    }
    function tick() {
      if (gameOver) return;
      if (canMove(current, 0, 1, 0)) {
        undrawTetromino(current);
        current.y++;
        update();
      } else {
        mergeTetromino(current);
        clearLines();
        current = next;
        next = randomTetromino();
        drawNext();
        if (!canMove(current, 0, 0, 0)) {
          gameOver = true;
          alert('Game Over! Your score: ' + score);
          clearInterval(interval);
        }
      }
      update();
    }
    function addRandomBottomBlocks() {
      // Fill 1 or 2 bottom rows with random blocks
      const numRows = Math.random() < 0.5 ? 1 : 2;
      for (let r = ROWS - numRows; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (Math.random() < 0.5) {
            const type = COLORS[Math.floor(Math.random() * COLORS.length)];
            grid[r][c].classList.add('filled', type);
          }
        }
      }
    }
    function restart() {
      if (interval) clearInterval(interval);
      createGrid();
      createNext();
      addRandomBottomBlocks();
      score = 0;
      gameOver = false;
      current = randomTetromino();
      next = randomTetromino();
      drawNext();
      update();
      interval = setInterval(tick, 500);
    }
    document.addEventListener('keydown', e => {
      if (gameOver) return;
      if (['ArrowLeft','ArrowRight','ArrowDown','ArrowUp',' '].includes(e.key)) e.preventDefault();
      if (e.key === 'ArrowLeft' && canMove(current, -1, 0, 0)) {
        undrawTetromino(current); current.x--; update();
      }
      if (e.key === 'ArrowRight' && canMove(current, 1, 0, 0)) {
        undrawTetromino(current); current.x++; update();
      }
      if (e.key === 'ArrowDown' && canMove(current, 0, 1, 0)) {
        undrawTetromino(current); current.y++; update();
      }
      if (e.key === 'ArrowUp' && canMove(current, 0, 0, 1)) {
        undrawTetromino(current); current.rotation = (current.rotation + 1) % 4; update();
      }
      if (e.key === ' ') {
        undrawTetromino(current);
        current = hardDropPos(current);
        update();
        tick();
      }
    });
    restartBtn.onclick = function() {
      if (gameOver) restart();
    };
    // Disable restart button during play
    function setRestartButtonState() {
      restartBtn.disabled = !gameOver;
      restartBtn.style.opacity = gameOver ? '1' : '0.5';
      restartBtn.style.cursor = gameOver ? 'pointer' : 'not-allowed';
    }
    // Patch game over logic to enable button
    const originalAlert = window.alert;
    window.alert = function(msg) {
      setTimeout(setRestartButtonState, 100); // enable after alert
      return originalAlert.apply(this, arguments);
    };
    // Patch update to disable during play
    const origUpdate = update;
    update = function() {
      setRestartButtonState();
      origUpdate();
    };
    // Start game
    restart();
  </script>
</body>
</html>
